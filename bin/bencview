#!/usr/bin/env ruby
# -*-ruby-*-

require 'bencode'
require_relative '../lib/bencview/trestle.rb'

include Bencview

$conf = Hash.new
u = Trestle.new($conf)

$conf[:banner] = "Usage: #{File.basename($0)} [options] file [file ...]"
$conf[:dump] = false

# Return a string--human redable number, e.g. 123456 becomes '123,456'.
def dn(n)
  return n.to_s if n.to_i/1000.0 < 1
  n.to_s.gsub!(/(\d)(?=(\d\d\d)+(?!\d))/, "\\1,")
end

# Convert _s_ from _enc_ to the default external encoding.
def ds(s, enc)
  s = s.to_s
  return s if (enc == Encoding.default_external || enc == "" || !enc)
  return dn(s) if s.match /^[0-9]+$/
  s.encode(Encoding.default_external, enc,
           :undef => :replace,
           :invalid => :replace)
end

# Read _s_ as a number of seconds from the Epoch and return a human
# readable date string.
def ddate(s)
  DateTime.strptime(s.to_s, '%s').rfc2822  
end

# --[ main ]------------------------------------------------------------

u.config_parse(['foobar']) {|src|
  o = u.cl_parse(src) # create an OptionParser object
  o.on('-d', 'Dump all as raw hash') {|i|
    $conf[:dump] = true
  }
  u.cl_parse(src, o) # run cl parser
}

# print our env
if $conf[:verbose] >= 2
  puts 'Libs dir: ' + Trestle.gem_libdir
  pp $conf
end

Trestle.errx(1, $conf[:banner]) if ARGV.size == 0

visfilesep = ARGV.size > 1 ? "\n" : "" # visual file separator
ARGV.each {|i|
  begin
    t = BEncode.load_file i
  rescue
    STDERR.puts "#{File.basename i}: #{$!}"
    next
  end

  puts visfilesep + 'FILE: ' + File.basename(i)
  if $conf[:dump]
    pp t
    next
  end
  enc = t['encoding'].to_s

  t.each {|k,v|
    case k
    when "announce-list"
        puts k + (v.size == 0 ? ':' : ":\n\t" + v.join("\n\t"))
    when "info"
      v.each {|info, infoval|
        case info
        when /piece/
          next # a big unredable blob
        when "files"
          total = 0
          puts "files (#{infoval.size}): "
          
          biggest = 0
          infoval.each {|i|
            biggest = i['length'] if biggest < i['length']
            total += i['length']
          }
          biggest = dn(biggest)
          
          infoval.each {|i|
            printf(" %#{biggest.size}s %s\n",
                   dn(i['length']), ds(i['path'].join('/'), enc))
          }
          puts 'length: ' + dn(total)
        else
          puts info + ': ' + ds(infoval, enc)
        end
      }
    when /date/
      puts k + ': ' + ddate(v)
    else
      puts k + ': ' + ds(v, enc)
    end
  }
}
